# Cap√≠tulo 8: Tipos avanzados.
## ‚ùì Tipos opcionales
En Motoko, al igual que en muchos otros lenguajes de programaci√≥n, hay un valor especial llamado `null` que se utiliza para representar la ausencia de un resultado. Esto es √∫til cuando se indica que una funci√≥n no devuelve nada. El valor `null` es del tipo `Null`, que solo contiene un valor: `null`.

Considera un arreglo de nombres llamado `names` y una funci√≥n llamada `find_name` que toma una lista de nombres como entrada y devuelve el √≠ndice de la primera aparici√≥n del nombre en el arreglo. Si no se encuentra el nombre, la funci√≥n debe devolver `null` en lugar de un √≠ndice. De esta manera, la funci√≥n indica que no encontr√≥ el nombre sin producir un error.

El siguiente c√≥digo no es v√°lido en Motoko:

```motoko
let names : [Text] = ["Motoko", "Rust", "JavaScript", "TypeScript"];
public func find_name(name : Text) : async Nat {
    var index : Nat = 0;
    for(language in names.vals()){
        if (language == name){
            return index;
        };
        index +=1;
    };
    return null; // We haven't found any match so we return null.
};
````
Motoko lanza un error porque `null` no es del tipo `Nat`. Para indicar que una funci√≥n puede devolver un valor `Nat` o `null`, necesitamos una forma de expresar que el tipo de retorno de la funci√≥n puede ser una de dos posibilidades. El valor de retorno espec√≠fico de la funci√≥n depende de la entrada, que es desconocida de antemano, por lo que no podemos predecir si la funci√≥n devolver√° un `Nat` o un `null` hasta que se ejecute.

Podemos usar un tipo opcional, `?T`, para expresar esto. En nuestro caso, usar√≠amos `?Nat`. Podemos reescribir nuestro c√≥digo usando esta notaci√≥n:
```motoko
let names : [Text] = ["Motoko", "Rust", "JavaScript", "TypeScript"];
public func find_name(name : Text) : async ?Nat {
    var index : Nat = 0;
    for(language in names.vals()){
        if (language == name){
            return ?index;
        };
        index +=1;
    };
    return null; // We haven't found any match so we return null.
};
```

El tipo opcional, indicado por `?`, se puede usar con cualquier otro tipo, como `?Text`, `?Int`, `?Bool`, y m√°s.

Adem√°s, el tipo opcional se usa a menudo con el patr√≥n `switch/case` en Motoko. Este patr√≥n te permite manejar un valor opcional y ejecutar diferentes partes de tu c√≥digo dependiendo de si el valor de entrada es `null` o no. Puedes usar el patr√≥n `switch/case` para verificar si un valor opcional est√° presente y realizar diferentes acciones en funci√≥n de eso, lo que resulta en un c√≥digo m√°s elegante y seguro.
```motoko
public func handle_null_value(n : ?Nat) : async Text {
    switch(n) {
        // Check if n is null 
        case(null){
            return ("The argument is null"); 
        };
        case(? something){
            return ("The argument is : " # Nat.toText(something));
        };
    };
};
```
Por √∫ltimo, la biblioteca Base proporciona un m√≥dulo **Option** para operar con valores opcionales. Por ejemplo, puedes usar la funci√≥n `Option.get()` para desempaquetar un valor opcional con un valor predeterminado:
```motoko
import Option "mo:base/Option";
actor {
    public func always_return_a_nat(n : ?Nat) : async Nat {
        return(Option.get(n, 0))
    };
}
```
Esta funci√≥n toma un valor `?Nat` como entrada y devuelve un `Nat`. Si proporcionas un valor `Nat` como entrada, devolver√° el mismo valor. Sin embargo, si proporcionas `null`, devolver√° el valor predeterminado, establecido en 0.
## üë§ Tipo gen√©rico
Un tipo gen√©rico, generalmente escrito como `T`, te permite escribir funciones y c√≥digo que pueden adaptarse a diferentes tipos. Cuando hablamos de `T`, se refiere a **cualquier tipo que desees**. Esto significa que puedes crear una sola funci√≥n o clase que pueda manejar varios tipos de entradas o datos, sin tener que escribir un c√≥digo separado para cada tipo.

Imaginemos que tenemos una tarea por delante: determinar si el tama√±o de un arreglo es par o no. Vamos a escribir una funci√≥n llamada `isArrayEven` que toma un arreglo como entrada y devuelve un valor `Bool` que indica si el tama√±o de ese arreglo es par o no.
```motoko
public func isArrayEven(array : [Nat]) : async Bool {
    let size = array.size();
    if(size % 2 == 0){
        return true;
    } else {
        return false;
    };
};
```
Esta funci√≥n funciona como se pretende, pero est√° limitada a arreglos llenos de `Nat`. Entonces, ¬øqu√© pasa si queremos verificar el tama√±o de un arreglo lleno de `Text` o `Int`? <br>
Un enfoque ser√≠a crear una funci√≥n separada para cada tipo posible:
- `isArrayEvenNat`
- `isArrayEvenText`
- `isArrayEvenInt`

Como puedes imaginar, esto r√°pidamente se vuelve dif√≠cil de manejar y mantener. Una soluci√≥n mejor es utilizar el poder de los gen√©ricos. Con los gen√©ricos, podemos escribir una sola funci√≥n que funcione para cualquier tipo de arreglo. Es una forma m√°s elegante y eficiente de resolver el problema. ¬°As√≠ que abracemos a nuestro nuevo amigo - los gen√©ricos - y hagamos que nuestro c√≥digo sea m√°s din√°mico y flexible!
```motoko
func isArrayEven<T>(array : [T]) : Bool {
    let size = array.size();
    if(size % 2 == 0){
        return true;
    } else {
        return false;
    };
};
```
Observa `<T>` despu√©s del nombre de la funci√≥n. Significa que esta funci√≥n ahora depende del tipo de `T`. Necesitamos especificar el tipo de `T` cuando queremos usar la funci√≥n.
```motoko
let array : [Nat] = [1,2,3,4];
let bool : Boolean = isArrayEvent<Nat>(array); // Replace T with the actual type when you use the function. 
```

Ya hemos utilizado gen√©ricos al trabajar con `Buffer` y `Array` sin mencionarlo.
- El tipo `Buffer<T>` es una clase gen√©rica y necesitamos proporcionar un tipo al crear un nuevo b√∫fer.
    ```motoko
    let b = Buffer.Buffer<Nat>(2);
    ```

- `Array.append<T>` es una funci√≥n gen√©rica y necesitamos proporcionar el tipo de los elementos de los arreglos que estamos concatenando.
    ```motoko
    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];
    Array.append<Nat>(array1, array2) // [1, 2, 3, 4, 5, 6];
    ```
## ü§´ Tipos compartidos
Cuando se env√≠a o recibe informaci√≥n desde un `actor` en Motoko, se utilizan tipos de datos espec√≠ficos llamados **tipos compartidos**. Estos **tipos compartidos** se utilizan en funciones `p√∫blicas` que pueden ser accedidas por otros actores. Por lo tanto, los **tipos compartidos** son los tipos de datos que se pueden usar como entrada o salida para estas funciones p√∫blicas, lo que permite que diferentes actores se comuniquen entre s√≠. <br/>

Si intentamos implementar [el siguiente actor](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=2185064550):
```motoko
actor {
  var mutableArray : [var Nat] = [var 1, 3, 5, 7]; 

  public func showArray() : async [var Nat] {
    return mutableArray
  };
}
```
Nos encontraremos con el siguiente error: `Error en el archivo Main.mo:3:28 la funci√≥n compartida tiene un tipo de retorno no compartido [var Nat] el tipo [var Nat] es o contiene un tipo no compartido var Nat`.

Una regla muy importante a recordar: **todo estado mutable siempre es privado de un actor.**

En resumen, todo lo que puedas modificar en el estado de tu contenedor debe considerarse privado y no podr√°s compartirlo con otros actores. <br/>

<p align="center"> <img src="../../../../manuals/chapters/chapter-8/assets/mutable_state_actor.png" width="800px" style="border: 2px solid black;"></p>
<p align="center"> Si es una variable, ¬°no puedes compartirlo fuera del actor!</p>


> Para obtener una descripci√≥n completa de todos los tipos compartidos, [consulta el libro de Motoko](https://web3.motoko-book.dev/internet-computer-programming-concepts/async-data/shared-types.html?highlight=Shared%20types#shared-types).

## üîÉ Tipos recursivos
Lee [esta secci√≥n](https://web3.motoko-book.dev/advanced-types/recursive-types.html) del libro de Motoko.
